///////////////////////////////////////////////////////////////////////////////
///
/// Copyright 2018-2020, Capvidia, Metrosage, and project contributors
/// https://www.capvidia.com/
/// 
/// This software is provided for free use to the QIF Community under the 
/// following license:
/// 
/// Boost Software License - Version 1.0 - August 17th, 2003
/// https://www.boost.org/LICENSE_1_0.txt
/// 
/// Permission is hereby granted, free of charge, to any person or organization
/// obtaining a copy of the software and accompanying documentation covered by
/// this license (the "Software") to use, reproduce, display, distribute,
/// execute, and transmit the Software, and to prepare derivative works of the
/// Software, and to permit third-parties to whom the Software is furnished to
/// do so, all subject to the following:
/// 
/// The copyright notices in the Software and this entire statement, including
/// the above license grant, this restriction and the following disclaimer,
/// must be included in all copies of the Software, in whole or in part, and
/// all derivative works of the Software, unless such copies or derivative
/// works are solely in the form of machine-executable object code generated by
/// a source language processor.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
/// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
/// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
/// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.

using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Re.AtnCompletion
{
    class TokenizationResult
    {
        public IReadOnlyList<IToken> Tokens { get; set; }
        public string UntokenizedText { get; set; } = string.Empty;
    }

    class TokenizationErrorListener : IAntlrErrorListener<int>
    {
        public TokenizationErrorListener(string input)
        {
            Input = input;
        }

        public string UntokenizedText { get; private set; } = string.Empty;

        public void SyntaxError([NotNull] IRecognizer recognizer, [Nullable] int offendingSymbol, int line, int charPositionInLine, [NotNull] string msg, [Nullable] RecognitionException e)
        {
            UntokenizedText = Input.Substring(charPositionInLine);
        }

        private string Input { get; set; }
    }

    class LexerWrapper
    {
        public LexerWrapper(ILexerFactory factory)
        {
            Factory = factory;
        }

        public IVocabulary Vocabulary => Lexer.Vocabulary;

        public TokenizationResult TokenizeNonDefaultChannel(string input)
        {
            var res = Tokenize(input);
            res.Tokens = res.Tokens.Where((t) => t.Channel == 0).ToList();
            return res;
        }

        public ATNState FindStateByRuleNumber(int ruleNumber)
        {
            return Lexer.Atn.ruleToStartState[ruleNumber];
        }

        public string FindRuleNameByRuleNumber(int ruleNumber)
        {
            return Lexer.RuleNames[ruleNumber];
        }

        private TokenizationResult Tokenize(string input)
        {
            Lexer = Factory.Create(new AntlrInputStream(input));
            var errorListener = new TokenizationErrorListener(input);
            Lexer.RemoveErrorListeners();
            Lexer.AddErrorListener(errorListener);
            return new TokenizationResult()
            {
                Tokens = Lexer.GetAllTokens().ToList(),
                UntokenizedText = errorListener.UntokenizedText
            };
        }

        Lexer Lexer
        {
            get
            {
                if (mLexer == null)
                    mLexer = Factory.Create(new AntlrInputStream(string.Empty));
                return mLexer;
            }
            set
            {
                mLexer = value;
            }
        }
        Lexer mLexer;

        ILexerFactory Factory { get; set; }
    }
}
